% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/stability-selection.R
\name{stability_selection}
\alias{stability_selection}
\alias{is_stab_sel}
\alias{print.stab_sel}
\alias{summary.stab_sel}
\alias{plot.stab_sel}
\title{Stability Selection}
\usage{
stability_selection(
  x,
  y = NULL,
  kernel = c("l1-logistic", "lasso", "ridge", "Cox", "pca.sd", "pca.thresh",
    "multinomial"),
  num_iter = 100,
  parallel = FALSE,
  alpha = 0.8,
  Pw = 0.5,
  num_perms = 0,
  standardize = TRUE,
  lambda_min_ratio = 0.1,
  beta_threshold = 0L,
  elastic_alpha = 1,
  lambda_pad = 20,
  impute_outliers = FALSE,
  impute_n_sigma = 3,
  r_seed = sample(1000, 1),
  ...
)

is_stab_sel(x)

\method{print}{stab_sel}(x, ...)

\method{summary}{stab_sel}(object, ..., thresh)

\method{plot}{stab_sel}(
  x,
  thresh = 0.6,
  custom_labels = NULL,
  main = NULL,
  sort_by_AUC = TRUE,
  ln_cols = unlist(col_palette),
  add_perm = FALSE,
  emp_thresh = seq(1, 0.1, by = -0.01),
  ...
)
}
\arguments{
\item{x}{A numeric \eqn{n x p} matrix of predictive features containing \code{n}
observation rows and \code{p} feature columns. Alternatively, a \code{stab_sel} class
object if passing to one of the S3 generic methods.}

\item{y}{The response variable. If kernel is "l1-logistic" then a
vector of binary class labels. If kernel is "Cox" then it is a two column
matrix with the event time in the first column and the censoring
indicator (1 = event, 0 = censored) in the second column.}

\item{kernel}{\code{character(1)}. A string describing the underlying model
used for selection. Options are:
\itemize{
\item "l1-logistic" (default)
\item "lasso"
\item "Cox"
\item "ridge"
\item "multinomial"
\item "pca.sd"
\item "pca.thresh"
}}

\item{num_iter}{\code{integer(1)}. Defining the number of
sub-sampling iterations for the stability selection.}

\item{parallel}{\code{logical(1)}. Should parallel processing
via multiple cores be implemented? Must be on a Linux
platform and have the \pkg{parallel}
package installed. Otherwise defaults to 1 core.}

\item{alpha}{\code{numeric(1)}. Value defining the weakness
parameter for the randomized regularization.
This is the minimum random weight applied to each
beta coefficient in the regularization.}

\item{Pw}{\code{numeric(1)}. Value defining probability of
a weak weight, see \code{alpha}. If \code{Pw = NA} then the
coefficient weights are sampled uniformly from \code{alpha} to 1.}

\item{num_perms}{\code{integer(1)}. The number of permutations
to use in calculating the empirical false positive rate.}

\item{standardize}{\code{logical(1)}. Whether the data should
be centered and scaled.}

\item{lambda_min_ratio}{The minimum value of
lambda/max(lambda) to use during
the selection procedure. See \code{\link[=glmnet]{glmnet()}}.}

\item{beta_threshold}{\code{numeric(1)}. Floating point value
defining selection levels for \verb{ridge regression}.
Since ridge regression will not zero out coefficients,
selection of coefficient curves by selection probability
is not effective. Any variable having a coefficient with
absolute value greater than or equal to \code{beta_threshold}
will be selected.}

\item{elastic_alpha}{\code{numeric(1)}. Floating point value
between 0 and 1. When 0, the results of \code{\link[=glmnet]{glmnet()}} are
equivalent to Ridge regression.
When 1, the results are equivalent to Lasso.
Any value between 0 and 1 creates a compromise
between L1 and L2 penalty.}

\item{lambda_pad}{The lambda path is padded with high
values of lambda in order to produce a more appealing plot.
Occasionally, the degree of padding needs to be
adjusted in order to produce better resolution at low
values of lambda. Typical values for this parameter
are 20 (default), 15, 10, or 5.}

\item{impute_outliers}{\code{logical(1)}. Should statistical
outliers (\eqn{3 * \sigma}) be imputed to approximate
a Gaussian distribution during stability selection?
See \code{\link[wranglr:impute_outliers]{wranglr::impute_outliers()}}.}

\item{impute_n_sigma}{\code{numeric(1)}. Standard deviation
outlier threshold for imputing outliers if
\code{impute_outliers = TRUE}, ignored otherwise.}

\item{r_seed}{\code{integer(1)}. Seed for the random number
generator, allowing for reproducibility of results.}

\item{...}{Additional arguments passed to one of the S3 methods for
\code{stab_sel} class objects, generics include:
\itemize{
\item \code{\link[=plot.stab_sel]{plot.stab_sel()}}
\item \code{\link[=print.stab_sel]{print.stab_sel()}}
\item \code{\link[=summary.stab_sel]{summary.stab_sel()}}
}}

\item{object}{An \code{stab_sel} class object.}

\item{thresh}{A numeric minimum selection probability threshold.
This value can also be a vector of values in \verb{[0, 1]},
but ideally greater than 0.50.}

\item{custom_labels}{a character vector of additional
features to label in the plot, see \code{Details}.}

\item{main}{optional title for the plot (defaultsdepend on the kernel used)}

\item{sort_by_AUC}{\code{logical(1)}. If \code{TRUE}, entries in
the legend will be sorted by their curve AUC values
which are in parentheses following the variable name
in the legend.}

\item{ln_cols}{A vector of colors to be used as
line colors in plotting. Colors are recycled as necessary.}

\item{add_perm}{Logical. Should empirical false discovery lines
from the null permutation be added to the plot
(if permutation was performed)? This can be time
consuming depending on the number of permutations performed,
so the default is \code{FALSE}.}

\item{emp_thresh}{a vector describing the empirical
threshold values to be used (\code{default = seq(1, 0.1, by = 0.01)}).}
}
\value{
A \code{stab_sel} class object:
\item{stabpath_matrix}{A matrix of \eqn{features x lambda_seq} containing
stability selection probabilities. A row in this matrix corresponds to a
stability selection path for a single feature.}
\item{lambda}{the sequence of lambdas used for regularization. They
correspond to the columns of \code{stabpath_matrix}.}
\item{alpha}{the weakness parameter provided in the call.}
\item{Pw}{the weak weight probability provided in the call.}
\item{kernel}{the kernel used (e.g. l1-logistic).}
\item{num_iter}{The number of iterations used in computing
the stability paths.}
\item{standardize}{should the data be standardized prior to analysis?}
\item{lambda_min_ratio}{?}
\item{perm_data}{Logical. Is there permuted data to perform empirical FDR?}
\item{permpath_list}{list containing information to calculated the
permutation paths of the empirical false positive rate.}
\item{perm_lambda}{The lambda used in the permuted lists.}
\item{permpath_max}{max lambda for the permuted lists (I think).}
\item{beta}{A matrix of the betas calculated during the selection process.}
\item{r_seed}{The random seed used.}

The \code{is_stab_sel} function returns a logical boolean.

The S3 print method returns:
\item{Stability Selection Kernel}{The kernel used in the stability selection
algorithm.}
\item{Weakness}{The weakness used (\code{alpha} argument).}
\item{Weakness Probability}{The probability of the weakness being applied
(\verb{Pw =} argument).}
\item{Number of Iterations}{Number of iterations in the selection
(\verb{num_iter =} argument).}
\item{Standardized}{Was the data standardized prior to stability selection?}
\item{Imputed Outliers}{Were statistical outliers imputed to the Gaussian
approximation prior to stability selection?}
\item{Lambda Max}{The maximum lambda (tuning parameter) used.}
\item{Lambda Max}{The maximum lambda (tuning parameter) used.}
\item{Random Seed}{The seed passed to the random number generator
for subset selection.}

A \code{ggplot}.
}
\description{
Performs stability selection on a set of predictive features and a response
variable. Stability selection is performed using a user-specified kernel.
For classification problems the \code{l1-logistic} kernel should be used and the
response should be a vector or factor of with two class labels. For lasso
the response column should be a numeric vector. For "Cox" the response is a
\emph{two column matrix} containing the event time in the first column and the
censoring indicator in the second column.
The randomized lasso is used if the \code{alpha} parameter is set to a value
less than 1. In a randomized Lasso the model coefficients are randomly
re-weighted when calculating the regularization term. This weighting can be
performed in two different ways. If \code{Pw = NA} then these random
weights are sampled uniformly between \code{alpha} and 1. If \code{Pw} is
supplied, then the random weights are chosen to be \code{alpha} with
probability \code{Pw} and 1 otherwise. The latter choice is used in Theorem
2 in Meinshausen and Buhlmann. Recommended values of \code{alpha} and
\code{Pw} are \verb{[0.5, 0.2]}.

The \code{\link[=is_stab_sel]{is_stab_sel()}} function checks whether
an object is class \code{stab_sel}. See \code{\link[=inherits]{inherits()}}.
}
\details{
Stability selection can be performed on multiple cores by setting
\code{parallel = TRUE}. This functionality requires
\code{\link[parallel:mclapply]{parallel::mclapply()}} from the \pkg{parallel} package.
This is \emph{not} available for Windows based OS.
}
\section{Functions}{
\itemize{
\item \code{print(stab_sel)}: S3 \code{print} method for class \code{stab_sel}.

\item \code{summary(stab_sel)}: The S3 \code{summary} method for class \code{stab_sel}.

\item \code{plot(stab_sel)}: The S3 \code{plot} method plots the selection paths for the features. This
plot closely resembles a lasso coefficient plot with the regularization
parameter (lambda) plotted on x-axis and the feature selection probability
(rather than the model coefficient) is plotted on the y-axis.

Plots the regularization parameter (lambda) on the x-axis and the selection
probability on the y-axis. The regularization parameter is plotted as
lambda/max(lambda) so that it is in the range from 1 to 0. The selection
probability corresponds to the number of times a particular marker was
chosen at a given value of lambda. Each line in the plot is a marker and
represents the stability selection path over the range of regularization
parameter. All features that have a maximum selection probability greater
than \code{thresh} (shown as a dotted horizontal line) are colored and labeled
and the remaining features are colored gray and unlabeled. Additionally, you
can provide a set of custom labels that will be colored and labeled
regardless of their max selection probability. Each feature is labeled with
a capital letter and the full name of the feature is indicated in the legend
along with the AUC for its curve in parentheses.

}}
\note{
Additional features can be passed as strings to the summary method
via the \code{add_features} argument.
}
\examples{
# l1-logistic
withr::with_seed(101, {
  n_feat      <- 20
  n_samp      <- 100
  x           <- matrix(rnorm(n_samp * n_feat), n_samp, n_feat)
  colnames(x) <- paste0("feat", "_", head(letters, n_feat))
  y           <- sample(1:2, n_samp, replace = TRUE)
  stab_sel    <- stability_selection(x, y, kernel = "l1-logistic", r_seed = 101)
})

# Cox
xcox <- feature_matrix(stabilityselectr:::log_rfu(simdata))

# Note: this works because colnames are already "time" and "status".
#   In 'real' datasets, you may need to rename the final matrix as
#   "time" and "status".

ycox <- select(simdata, time, status) |> as.matrix()
stab_sel_cox <- stability_selection(xcox, ycox, kernel = "Cox", r_seed = 3)
# Test for class `stab_sel`
is_stab_sel(stab_sel)

# S3 print method
stab_sel

# S3 summary method
summary(stab_sel, thresh = 0.6)
summary(stab_sel, thresh = 0.8, add_features = "feat_c")   # force feat_c into table
# S3 plot method
plot(stab_sel, thresh = 0.8)

}
\references{
Meinshausen, N. and Buhlmann, P. (2010), Stability selection.
Journal of the Royal Statistical Society: Series B (Statistical
Methodology), 72: 417-473. doi: 10.1111/j.1467-9868.2010.00740.x
}
\seealso{
\code{\link[=glmnet]{glmnet()}}, \code{\link[=get_stable_features]{get_stable_features()}}
}
\author{
Michael R. Mehan, Stu Field, and Robert Kirk DeLisle
}
